{% extends 'base.html' %}

{% block header %}{% endblock %}

{% block content %}
<div class="joke-container">
  <div class="page-header">
    <h1>{% block title %}Master of Jokes{% endblock %}</h1>
    {% if g.user %}
      <a class="btn-new-joke" href="{{ url_for('jokes.leave') }}">+ New Joke</a>
    {% endif %}
  </div>

  {% if jokes %}
    <div class="jokes-list">
    {% for joke in jokes %}
      <div class="joke-card" data-avg-rating="{{ joke['avg_rating'] }}" data-created="{{ joke['created'].isoformat() }}">
        <div class="joke-header">
          <div>
            <h2 class="joke-title">{{ joke['title'] }}</h2>
            <div class="joke-meta">
              <span>Posted by <span class="joke-author">@{{ joke['username'] }}</span></span>
              <span>‚Ä¢</span>
              <span>{{ joke['created'].strftime('%B %d, %Y') }}</span>
            </div>
          </div>
          {% if g.user and g.user['id'] == joke['author_id'] %}
            <div class="joke-actions">
              <a class="btn-edit" href="{{ url_for('jokes.update', id=joke['id']) }}">‚úèÔ∏è Edit</a>
            </div>
          {% endif %}
        </div>
        <p class="joke-body">{{ joke['body'] }}</p>
        
        <!-- Star Rating Section -->
        <div class="rating-container">
          {% if g.user %}
            <div class="star-rating" data-joke-id="{{ joke['id'] }}">
              {% for i in range(1, 6) %}
                <span class="star {% if user_ratings.get(joke['id']) and user_ratings[joke['id']] >= i %}filled user-rated{% elif joke['avg_rating'] >= i %}filled{% endif %}" 
                      data-rating="{{ i }}">‚òÖ</span>
              {% endfor %}
            </div>
          {% else %}
            <div class="star-rating">
              {% for i in range(1, 6) %}
                <span class="star {% if joke['avg_rating'] >= i %}filled{% endif %}">‚òÖ</span>
              {% endfor %}
            </div>
          {% endif %}
          
          <div class="rating-info">
            <span class="avg-rating">{{ "%.1f"|format(joke['avg_rating']) }}</span>
            <span class="rating-count">({{ joke['rating_count'] }} rating{{ 's' if joke['rating_count'] != 1 else '' }})</span>
          </div>
        </div>
      </div>
    {% endfor %}
    </div>
  {% else %}
    <div class="empty-state">
      <div class="empty-state-icon">üò¢</div>
      <p class="empty-state-text">No jokes yet!</p>
      <p>Be the first to share a joke and make everyone laugh!</p>
      {% if g.user %}
        <a href="{{ url_for('jokes.leave') }}" class="btn-primary" style="margin-top: 1rem; display: inline-block;">Share Your First Joke</a>
      {% else %}
        <a href="{{ url_for('auth.login') }}" class="btn-primary" style="margin-top: 1rem; display: inline-block;">Login to Share Jokes</a>
      {% endif %}
    </div>
  {% endif %}
</div>

<script>
function rateJoke(jokeId, rating) {
  fetch(`/${jokeId}/rate`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
    },
    body: `rating=${rating}`
  })
  .then(response => response.json())
  .then(data => {
    if (data.success) {
      // Update the stars
      const jokeCard = document.querySelector(`.star-rating[data-joke-id="${jokeId}"]`).closest('.joke-card');
      const starContainer = jokeCard.querySelector(`.star-rating[data-joke-id="${jokeId}"]`);
      const stars = starContainer.querySelectorAll('.star');
      stars.forEach((star, index) => {
        star.classList.remove('filled', 'user-rated');
        if (index < rating) {
          star.classList.add('filled', 'user-rated');
        }
      });
      
      // Update rating info
      const ratingInfo = starContainer.nextElementSibling;
      ratingInfo.querySelector('.avg-rating').textContent = data.avg_rating.toFixed(1);
      ratingInfo.querySelector('.rating-count').textContent = 
        `(${data.rating_count} rating${data.rating_count !== 1 ? 's' : ''})`;
      
      // Store the new average rating in the card for sorting
      jokeCard.dataset.avgRating = data.avg_rating;
      
      // Show success message
      showMessage('Rating saved! ‚≠ê');
      
      // Reorder jokes after a brief delay to show the update
      setTimeout(() => reorderJokes(), 500);
    } else {
      showMessage('Error saving rating', true);
    }
  })
  .catch(error => {
    console.error('Error:', error);
    showMessage('Error saving rating', true);
  });
}

function reorderJokes() {
  const jokesContainer = document.querySelector('.jokes-list');
  if (!jokesContainer) return;
  
  const jokeCards = Array.from(jokesContainer.querySelectorAll('.joke-card'));
  
  // Sort by average rating (highest first), then by creation date
  jokeCards.sort((a, b) => {
    const ratingA = parseFloat(a.dataset.avgRating || 0);
    const ratingB = parseFloat(b.dataset.avgRating || 0);
    
    if (ratingB !== ratingA) {
      return ratingB - ratingA; // Higher rating first
    }
    
    // If ratings are equal, sort by created date (newer first)
    const dateA = new Date(a.dataset.created);
    const dateB = new Date(b.dataset.created);
    return dateB - dateA;
  });
  
  // Add fade out effect
  jokeCards.forEach(card => {
    card.style.opacity = '0.3';
    card.style.transform = card.style.transform + ' scale(0.95)';
  });
  
  // Re-append in new order after brief delay
  setTimeout(() => {
    jokeCards.forEach(card => jokesContainer.appendChild(card));
    
    // Fade back in with cascading effect
    setTimeout(() => {
      jokeCards.forEach(card => {
        card.style.opacity = '';
        card.style.transform = '';
      });
    }, 100);
  }, 300);
}

function showMessage(text, isError = false) {
  const message = document.createElement('div');
  message.className = 'rating-message';
  message.textContent = text;
  if (isError) {
    message.style.background = 'linear-gradient(135deg, #ffeaa7 0%, #fdcb6e 100%)';
    message.style.color = '#d63031';
  }
  document.body.appendChild(message);
  
  setTimeout(() => {
    message.style.animation = 'slideInRight 0.3s ease-out reverse';
    setTimeout(() => message.remove(), 300);
  }, 2000);
}

// Add hover effect and click handlers for stars
document.addEventListener('DOMContentLoaded', function() {
  document.querySelectorAll('.star-rating[data-joke-id]').forEach(container => {
    const jokeId = container.getAttribute('data-joke-id');
    const stars = container.querySelectorAll('.star');
    
    stars.forEach((star, index) => {
      const rating = parseInt(star.getAttribute('data-rating'));
      
      // Add click handler
      star.addEventListener('click', function() {
        console.log(`Clicking star ${rating} for joke ${jokeId}`);
        rateJoke(jokeId, rating);
      });
      
      // Add hover effect
      star.addEventListener('mouseenter', function() {
        stars.forEach((s, i) => {
          if (i <= index) {
            s.classList.add('hovered');
          } else {
            s.classList.remove('hovered');
          }
        });
      });
    });
    
    container.addEventListener('mouseleave', function() {
      stars.forEach(s => s.classList.remove('hovered'));
    });
  });
  
  // Update card z-index based on scroll position
  updateCardStacking();
  window.addEventListener('scroll', updateCardStacking);
});

function updateCardStacking() {
  const cards = document.querySelectorAll('.joke-card');
  const scrollY = window.scrollY;
  const windowHeight = window.innerHeight;
  const viewportMiddle = scrollY + windowHeight / 2;
  
  cards.forEach((card, index) => {
    const cardRect = card.getBoundingClientRect();
    const cardTop = scrollY + cardRect.top;
    const cardBottom = cardTop + cardRect.height;
    const cardMiddle = cardTop + cardRect.height / 2;
    
    // Calculate distance from viewport middle
    const distanceFromMiddle = Math.abs(cardMiddle - viewportMiddle);
    
    // Calculate z-index based on position
    // Cards closer to middle get higher z-index
    const baseZIndex = 100;
    const zIndex = baseZIndex + cards.length - Math.floor(distanceFromMiddle / 50);
    card.style.zIndex = zIndex;
    
    // Add classes based on position relative to viewport middle
    card.classList.remove('in-view', 'above-view', 'below-view');
    
    if (cardMiddle < viewportMiddle - 100) {
      card.classList.add('above-view');
    } else if (cardMiddle > viewportMiddle + 100) {
      card.classList.add('below-view');
    } else {
      card.classList.add('in-view');
    }
    
    // Add slight rotation and translation for depth effect
    const rotation = (cardMiddle - viewportMiddle) / windowHeight * 3; // Max 3 degrees
    const translateY = (cardMiddle - viewportMiddle) / windowHeight * 10; // Max 10px
    
    if (!card.matches(':hover')) {
      card.style.transform = `translateY(${translateY}px) rotateX(${-rotation}deg) scale(${card.classList.contains('in-view') ? 1 : 0.97})`;
    }
  });
}
</script>
{% endblock %}
